# Работа с Jenkins pipeline


# Описание используемого подхода/решения

Старался использовать встроенный интрументарий вместо своих скриптов.

1. Забираем файлы из пары проектов, каждый со своего репозитория;
1. Собираем *docker*-образ для каждого из проектов;
1. Поднимаем-удаляем собранные сервисы (скорее тест);
1. Разворачиваем сервисы рядом с Jenkins и Git-server.

Для параллельного выполнения задач пригодился *parallel*, внутри которого описываю *stage* по задачам, которые нужно параллелить.


# Описание проблем, с которымм столкнулся, и их решение

1. Не хватало плагинов. Доустанавливал их по мере необходимости;
1. По умолчанию оба веб-сервиса сливались в *pipeline workspace* - помогает *dir()*. Писать в ручную *workspace/<pipeline_name>* показалось не очень красиво, потому использовал доступную  переменную *env.WORKSPACE*;
1. Хотел в завершение развернуть сервисы в Docker с помощью *agent docker*, да тот самостоятельно останавливает контейнеры. Можно сделать некую задержку, например, с помощью взаимодействия с пользователем в процессе, спрашивая, всё ли уже получил от запущенных контейнеров, но это не то. Потому выбор пал на *post* с триггером *success* - тут череда команд, как если бы писали в рамках *steps*, пытающаяся остановить уже запущенные контецнеры, удалить их (чтобы освободить имя), запустить сервисв в той же сети, где и сам Jenkins, чуть подождать, пока сервисв запустятся, получить http-заглушки сервисов и вывести *docker ps* по интересующим сервисам.
